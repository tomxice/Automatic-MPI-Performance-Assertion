#include "parser.h"

#define PAR_L1(op,n_op) \
    if (ns == init) { \
        int ret = sscanf(line,"%s%s%s%d",str0,str1,str2,&proc);  \
        if (ret != 4) break; \
        if (strcmp(str1,"#processes") == 0) \
        pimb->op[pimb->n_op].proc = proc; \
    } \
    else if (ns == data) { \
        int bytes, rep; \
        double t0; \
        int ret = sscanf(line,"%d%d%lf",&bytes,&rep,&t0); \
        if (ret != 5) { \
            break; \
        } \
        int n_byte = pimb->op[pimb->n_op].n_byte ++; \
        pimb->op[pimb->n_op].para[n_byte].bytes = bytes; \
        pimb->op[pimb->n_op].para[n_byte].t_avg = t0; \
    } \
    else if (ns == op ) { \
        ++ pimb->n_op; \
    } \
    else { \
        s = ns; \
        ++ pimb->n_op; \
    } 

#define PAR_L2(op,n_op) \
    if (ns == init) { \
        int ret = sscanf(line,"%s%s%s%d",str0,str1,str2,&proc);  \
        if (ret != 4) break; \
        if (strcmp(str1,"#processes") == 0) \
        pimb->op[pimb->n_op].proc = proc; \
    } \
    else if (ns == data) { \
        int bytes, rep; \
        double t0, t1, t2; \
        int ret = sscanf(line,"%d%d%lf%lf%lf",&bytes,&rep,&t0,&t1,&t2); \
        if (ret != 5) { \
            break; \
        } \
        int n_byte = pimb->op[pimb->n_op].n_byte ++; \
        pimb->op[pimb->n_op].para[n_byte].bytes = bytes; \
        pimb->op[pimb->n_op].para[n_byte].t_min = t0; \
        pimb->op[pimb->n_op].para[n_byte].t_max = t1; \
        pimb->op[pimb->n_op].para[n_byte].t_avg = t2; \
    } \
    else if (ns == op ) { \
        ++ pimb->n_op; \
    } \
    else { \
        s = ns; \
        ++ pimb->n_op; \
    } 
// parameters
// f_para: the data file
// loggps: a struct where to store data,
//         pass the head pointer here

#define LOGP_FILE_LATENCY_R "# Latency = %lf\n"
#define LOGP_FILE_OVERHEAD_R "# Os_0 = %lf Or_0 = %lf\n"

void parse_loggpo(const char* f_para, pLogGPO logps) {
    memset(logps, 0, sizeof(LogGPO));
    FILE* pf_para = NULL;
    pf_para = fopen(f_para,"r");
    if (! pf_para) {
        printf("file open failed!\n");
    }

    // read the file
    int index = 0;
    int LINES = 200;
    char line[LINES];
    if (line == fgets(line, LINES, pf_para))
        sscanf(line, LOGP_FILE_LATENCY_R, &logps->latency);
    if (line == fgets(line, LINES, pf_para))
        sscanf(line, LOGP_FILE_OVERHEAD_R, &logps->os_0, &logps->or_0);
    while (line == fgets(line, LINES, pf_para)) {
        pLoggpoPara p = &(logps->para[index]); 
        int ret = sscanf(line, "%d%lf%lf%lf%lf%lf%lf%lf", 
          &p->size, &p->os, &p->or, &p->ov, &p->sr, &p->gap, &p->rtt, &p->rtt100);
        if (ret == 8) ++index;
    }
    logps->n_size = index;
    // verify
    #ifdef VERIFY
    printf("n_size;%d\n", logps->n_size);
    printf("latency:%f\n",logps->latency);
    printf("os_0:%f, or_0:%f\n", logps->os_0, logps->or_0);
    for (int i = 0; i < index; ++ i) {
        pLoggpoPara p = &(logps->para[i]); 
        printf("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
          p->size, p->os, p->or, p->ov, p->sr, p->gap, p->rtt, p->rtt100);
    }
    #endif
}

// this function tells you which benchmark we are in
IMBState test_benchmark(const char* line) {
    bool comment = false;
    for (int i = 0; i < strlen(line); ++ i) {
        if (line[i] == '#') {
            comment = true;
            break;
        }
    }
    if (comment == false) return data;

    if (strcmp(line,"# All processes entering MPI_Finalize\n") == 0) {
        //printf("Finalize\n");
        return end;
    }

    char str0[100], str1[100], str2[100];
    int ret = sscanf(line, "%s%s%s", str0, str1, str2);
    if (ret != 3) return init;
    if (strcmp(str1,"Benchmarking") != 0) return init;

    IMBState s = unknown;
    if (strcmp(str2,"PingPong") == 0) s = pingpong;
    else if (strcmp(str2,"PingPing") == 0) s = pingping;
    else if (strcmp(str2,"Sendrecv") == 0) s = sendrecv;
    else if (strcmp(str2,"Exchange") == 0) s = exchange;
    else if (strcmp(str2,"Allreduce") == 0) s = allreduce;
    else if (strcmp(str2,"Reduce") == 0) s = reduce;
    else if (strcmp(str2,"Reduce_scatter") == 0) s = reduce_scatter;
    else if (strcmp(str2,"Allgather") == 0) s = allgather;
    else if (strcmp(str2,"Allgatherv") == 0) s = allgatherv;
    else if (strcmp(str2,"Gather") == 0) s = gather;
    else if (strcmp(str2,"Gatherv") == 0) s = gatherv;
    else if (strcmp(str2,"Scatter") == 0) s = scatter;
    else if (strcmp(str2,"Scatterv") == 0) s = scatterv;
    else if (strcmp(str2,"Alltoall") == 0) s = alltoall;
    else if (strcmp(str2,"Alltoallv") == 0) s = alltoallv;
    else if (strcmp(str2,"Bcast") == 0) s = bcast;
    else if (strcmp(str2,"Barrier") == 0) s = barrier;
    else s = init;
    return s;
}
    

// parameters
// f_para: data file generated by IMB
// pimb: a pointer to IMBPara, which stores IMB data
void parse_imb(const char* f_para, pIMBPara pimb) {
    memset(pimb, 0, sizeof(IMBPara));
    FILE* pf_para = NULL;
    pf_para = fopen(f_para,"r");
    if (! pf_para) {
        printf("file open failed!\n");
    }

    // read the file
    int proc=-1;
    int LINES = 200;
    char line[LINES];
    char str0[100], str1[100], str2[100];
    IMBState s = init, ns;
    // read a line
    while (line == fgets(line, LINES, pf_para)) {
        // empty line
        if (strlen(line) == 0) {
            ns = data;
            continue;
        }
            
        ns = test_benchmark(line);
        //printf("line:%s,state:%d,newstate:%d\n",line,s,ns);
        switch (s) {
        case init:
            if (ns >= init && ns <= end)
                s = ns;
            break;
        case barrier:
            if (ns == init) {
                int ret = sscanf(line, "%s%s%s%d", str0, str1, str2, &proc);
                if (ret != 4) break;
                if (strcmp(str1,"#processes") == 0)
                    pimb->barrier[pimb->n_barrier].proc = proc;
            }
            else if (ns == data) {
                int rep;
                double t0, t1, t2;
                int ret = sscanf(line,"%d%lf%lf%lf", &rep, &t0, &t1, &t2);
                if (ret != 4) { 
                    //printf("Read parameters error\n");
                    break;
                }
                pimb->barrier[pimb->n_barrier].t_min = t0;
                pimb->barrier[pimb->n_barrier].t_max = t1;
                pimb->barrier[pimb->n_barrier].t_avg = t2;
            }
            else if (ns == barrier) {
                ++ pimb->n_barrier;
            }
            else {
                s = ns;
                ++ pimb->n_barrier;
            }
            break;
        case pingpong:
            PAR_L1(pingpong,n_pingpong)
            break;
        case pingping:
            PAR_L1(pingping,n_pingping)
            break;
        case sendrecv:
            PAR_L2(sendrecv,n_sendrecv)
            break;
        case exchange:
            PAR_L2(exchange,n_exchange)
            break;
        case allreduce:
            PAR_L2(allreduce,n_allreduce)
            break;
        case reduce:
            PAR_L2(reduce,n_reduce)
            break;
        case reduce_scatter:
            PAR_L2(reduce_scatter,n_reduce_scatter)
            break;
        case allgather:
            PAR_L2(allgather,n_allgather)
            break;
        case allgatherv:
            PAR_L2(allgatherv,n_allgatherv)
            break;
        case scatter:
            PAR_L2(scatter,n_scatter)
            break;
        case scatterv:
            PAR_L2(scatterv,n_scatterv)
            break;
        case alltoall:
            PAR_L2(alltoall,n_alltoall)
            break;
        case alltoallv:
            PAR_L2(alltoallv,n_alltoallv)
            break;
        case bcast:
            PAR_L2(bcast,n_bcast)
            break;
        case end:
        case data:
        case unknown:
        default:
            if (ns >= init && ns <= end)
                s = ns;
            break;
        }
    }

    #ifdef VERIFY
    printf("Barrier\n-----------\n");
    for (int i = 0; i < pimb->n_barrier; ++ i) {
        printf("proc: %d, tmin: %8f tmax: %8f tavg: %8f\n",
          pimb->barrier[i].proc, pimb->barrier[i].t_min,
          pimb->barrier[i].t_max, pimb->barrier[i].t_avg);
    }
    printf("\nBcast\n-----------\n");
    for (int i = 0; i < pimb->n_bcast; ++ i) {
        printf("proc: %d\n", pimb->bcast[i].proc);
        for (int j = 0; j < pimb->bcast[i].n_byte; ++ j) {
            printf(" bytes: %d, tmin: %8f tmax: %8f tavg %8f\n",
              pimb->bcast[i].para[j].bytes,
              pimb->bcast[i].para[j].t_min,
              pimb->bcast[i].para[j].t_max,
              pimb->bcast[i].para[j].t_avg);
        }
    }
    printf("\nReduce\n-----------\n");
    for (int i = 0; i < pimb->n_reduce; ++ i) {
        printf("proc: %d\n", pimb->reduce[i].proc);
        for (int j = 0; j < pimb->reduce[i].n_byte; ++ j) {
            printf(" bytes: %d, tmin: %8f tmax: %8f tavg %8f\n",
              pimb->reduce[i].para[j].bytes,
              pimb->reduce[i].para[j].t_min,
              pimb->reduce[i].para[j].t_max,
              pimb->reduce[i].para[j].t_avg);
        }
    }
    printf("\nGather\n-----------\n");
    for (int i = 0; i < pimb->n_gather; ++ i) {
        printf("proc: %d\n", pimb->gather[i].proc);
        for (int j = 0; j < pimb->gather[i].n_byte; ++ j) {
            printf(" bytes: %d, tmin: %8f tmax: %8f tavg %8f\n",
              pimb->gather[i].para[j].bytes,
              pimb->gather[i].para[j].t_min,
              pimb->gather[i].para[j].t_max,
              pimb->gather[i].para[j].t_avg);
        }
    }
    printf("\nAllreduce\n-----------\n");
    for (int i = 0; i < pimb->n_allreduce; ++ i) {
        printf("proc: %d\n", pimb->allreduce[i].proc);
        for (int j = 0; j < pimb->allreduce[i].n_byte; ++ j) {
            printf(" bytes: %d, tmin: %8f tmax: %8f tavg %8f\n",
              pimb->allreduce[i].para[j].bytes,
              pimb->allreduce[i].para[j].t_min,
              pimb->allreduce[i].para[j].t_max,
              pimb->allreduce[i].para[j].t_avg);
        }
    }
    printf("\nAllgather\n-----------\n");
    for (int i = 0; i < pimb->n_allgather; ++ i) {
        printf("proc: %d\n", pimb->allgather[i].proc);
        for (int j = 0; j < pimb->allgather[i].n_byte; ++ j) {
            printf(" bytes: %d, tmin: %8f tmax: %8f tavg %8f\n",
              pimb->allgather[i].para[j].bytes,
              pimb->allgather[i].para[j].t_min,
              pimb->allgather[i].para[j].t_max,
              pimb->allgather[i].para[j].t_avg);
        }
    }
    #endif
}

// this main is for test parser
#ifdef PAR_TEST
LogGPO logps;
IMBPara imb;
int main() {
    parse_loggpo("paras/cmp_para", &logps);
    //parse_imb("paras/coll_para", &imb);
    return 0;
}
#endif

          
        
